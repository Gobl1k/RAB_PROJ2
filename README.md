# RAB_PROJ2

Реализация высокопроизводительного канала передачи сжатых данных между двумя процессами через общую память ограниченного размера (256 байт на блок).

## Особенности решения

Два отдельных процесса: `producer` и `consumer`
Общая память строго ограничена (256-байтные блоки + кольцевой буфер)
Многопоточное сжатие с потерями (квантование по динамическому диапазону блока)
Коэффициент сжатия: **25-45×** (в зависимости от данных)
Ускорение относительно передачи без сжатия: **30-40×**
Потеря точности: **< 0.5%** (RMSE ≈ 0.0003 - 0.0008)
Порядок данных строго сохранён
Кроссплатформенность: Linux + Windows (MSYS2/MinGW)
Зависимость: только Boost.Interprocess (header-only в большинстве случаев)

### Ход решения

1. **Главная проблема - 256 байт**  
   Посчитал: 50 МБ ≈ 12 500 000 float-ов. Без сжатия в 256 байт влезает только 64 значения → примерно 195 000 передач. Даже если каждая мгновенная - всё равно очень долго.  
   Сразу понял: нужно сжатие хотя бы в 15-20 раз, иначе по времени не выиграем.

2. **Почему отказался от Zlib/LZ4/Zstd**  
   Поставил эксперименты - на случайных float-ах они дают максимум 1.5-2×. Плюс заголовки и оверхед.  
   Быстро стало ясно, что lossless тут не поможет. ТЗ разрешает потерю данных > перешёл на lossy-подход.

3. **Алгоритм сжатия, который придумал сам**  
   Самое простое и эффективное:  
   - беру блок примерно 12-14 тысяч float-ов  
   - нахожу в нём min и max  
   - привожу каждое значение к 0..255 (8 бит)  
   - сохраняю min (4 байта) + max (4 байта) + все 8-битные значения  

   Итого после сжатия примерно 14 КБ > легко влезает в 236 байт полезной нагрузки.  
   Сжатие получается 30-45×, а потеря точности почти незаметна (обычно меньше 0.1%).

4. **Общая память**  
   Сначала хотел писать на чистом POSIX (`shm_open` + `mmap`) - это классика под Linux.  
   Потом вспомнил, что тестовое могут проверять и на Windows, а в MinGW этого нет.  
   Нашёл Boost.Interprocess - работает и на Linux, и в MSYS2 без правок. Да, чуть тяжелее, но зато кроссплатформенно.

5. **Почему два отдельных exe, а не fork()**  
   Сначала сделал один exe с `fork()` - красиво и по-юниксовски.  
   Но в MSYS2 `fork` просто нет - всё падало.  
   Решил сделать два отдельных исполняемых файла - надёжнее, проще и полностью соответствует ТЗ (два процесса).

6. **Компромиссы, на которые пошёл**  
   - lossy-сжатие - есть небольшая потеря точности, но ТЗ разрешает, а выигрыш по времени огромный  
   - зависимость от Boost - зато кроссплатформенность  
   - нет многопоточности внутри producer/consumer

7. **Что можно было бы улучшить (я это понимаю)**  
   - SIMD/AVX2 для поиска min/max - будет ещё быстрее  
   - многопоточное сжатие и декомпрессия внутри каждого процесса  
   - адаптивный размер блока под конкретные данные  
   - дельта-кодирование + RLE поверх квантования - ещё +20-30% сжатия без заметной потери качества

Спасибо за интересное задание! Было сложно, но я много нового узнал про IPC и сжатие с потерями.  
Готов обсудить всё это на собеседовании.

## Сборка и запуск

Решение протестировано и гарантированно работает на **Linux** (Ubuntu 20.04/22.04/24.04, Debian, а также в WSL2 и MSYS2 UCRT64).

### На Linux

```bash
# Установка зависимостей (Ubuntu/Debian)
sudo apt update
sudo apt install cmake g++ libboost-all-dev

# Сборка
cmake -B build -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release
cmake --build build --config Release

# Запуск
./build/producer source_data.bin          # терминал 1
./build/consumer result_data.bin          # терминал 2
